- A developer is also a user.
- Be users/developers centric, not trends centric.
- If it's not usable, it's not secure.
- Less configuration means less complication.
- Use principles such as the Law of Demeter or Separation Of Concerns as a mean to establish a clear definition of what each part of the software's job is. The cutting corners mindset should be antagonized.
- Try not to assume that the user is using X tool or Y software. Once the stack has left it up to the software, it's its job to maintain that good experience until it passes the torch itself.
- While experimenting is most certainly always a good idea, [try not to fall for the overcomplicate things mindset trap](http://motherfuckingwebsite.com/).
- Programming can be seen as a way for us to dematerialize by conceptualizing the complexities of the world around us, which is why it should be as verbose as one can take.
- Write documentation for every types of users not just for your buddies.
- Justify any architectural or design choice.
- Intuitive but not repetitive; aims for a progressive user/developer experience with well thought and minimal default behaviors.
- Think about the stack from the very bottom of it up to the highest heights (is it extensible? can it be easily debugged? can things be reversed?).
- Making software is good, maintaining them alive is even better. Learn from the past by looking at the state of other OSS projects and what can be done (better) to things afloat.
- Any software attempting to "solve" a problem bigger than himself should never be trusted in the first place. I consider Swiss Army knife softwares as evil.
- Source code is certainly, without any doubt, NOT a reasonable replacement for documentation.
- Try to flow smoothly along whatever specifications govern your ecosystem.
- Think add not replace. Reinforcing expectations and fixing flaws in existing systems is much more rewarding.

What about you? What's your manifesto?
